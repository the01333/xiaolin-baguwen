1. 介绍一下聚集索引和非聚集索引
    聚集索引的表记录是按照索引顺序存储的, 一张表只能有一个聚集索引, 聚集索引构成的索引树的叶节点存储索引键和行数据, 
根据聚集索引查询时无须“回表”; 
    而非聚集索引所构成的索引树的叶节点存储索引键和主键（如果没有显示指定则存储 Row_ID, 可以直接定位到物理上的具体数据位置）,
因为存储的是主键, 所以还需要去聚集索引进行“回表”查询

2. 介绍一下 InnoDB 和 MyISAM
    InnoDB 支持事务提供了 ACID 特性; 还支持外键, 保证了数据的一致性和完整性; 使用的是行级锁, 锁的粒度细, 支持高并发; 
数据和索引存储在 .ibd 文件;
    MyISAM 不支持事务、外键; 使用的是表级锁; 数据和索引分别存储在 .MYD 和 .MYI 文件    

3. 索引失效场景
    1️⃣使用函数或表达式
    2️⃣适用 or 连接条件
    3️⃣隐式类型转换
    4️⃣前导模糊查询
    5️⃣使用不等于
    6️⃣范围条件后的索引失效
    7️⃣不满足最左前缀原则
    等等

4. B树和B+树的区别
    B树的每个节点都存储索引键、数据和子节点指针, 数据可能在任意层;
    B+树的非叶子节点只存储索引键和子节点指针, 数据都存储在叶子节点中, 此外节点之间都用指针相连, 形成有序的链表（MySQL中优化为双向链表）, 
更适合范围查询和排序操作, 是 MySQL 索引的主要实现结构

5. 主从同步原理
    首先主服务器的更改操作都会存入到本地的二进制日志中, 从服务器会开启一个 IO 线程去读取主服务器的二进制日志, 然后写入从服务器的中继日志, 
然后还会开启一个 sql 线程去应用这些更改的数据（这个过程中会生成一个复制事件并更新到主服务器的复制信息表中, 记录从服务器的接收和应用二进制日志事件的相关信息）, 
这样就实现了主从的数据一致

6. 介绍一下 MVCC
    MVCC 是一种 InnoDB 实现高并发读写的机制, 通过隐藏列 + Undo Log + Read View 维护每行数据的多个版本, 
在不加锁的情况下让事务读到自己应读的数据, 用于实现快照读;
     - 核心实现原理:
        1️⃣隐藏列: 每行数据除了定义的字段外, 还维护三个隐藏字段 - DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID;
        2️⃣Undo Log: 事务在修改数据时, 会把旧值写入 Undo Log, 形成版本链, 之后可以通过 DB_ROLL_PTR 回溯旧版本;
        3️⃣Read View: 事务在执行快照读时, 会生成一个 Read View, 它记录哪些事务已提交、哪些未提交,
        其中有四个关键字段 - m_ids（当前活跃/未提交的事务 ID 列表）、min_trx_id、max_trx_id、creator_trx_id
        事务读取记录时, Read View 是否可见的判断逻辑:
            （1）如果记录的 DB_TRX_ID < min_trx_id, 说明该事务在当前事务开启前已启动 -> 可见
            （2）如果记录的 DB_TRX_ID > max_trx_id, 说明该事务在当前事务开启后才启动 -> 不可见
            （3）如果记录的 DB_TRX_ID 存在于 m_ids 中, 说明事务未提交, 不可见
     - 生效的隔离级别: 
        RC、RR, 可以防止脏读和不可重复读, 可以通过 Next-Key Lock 解决幻读        

7. 什么是当前读、快照读
    当前读: 读取数据时获取最新的、已经提交的数据版本（读取过程中可能会加锁, 确保读取到的是最新的数据, 并且不会被其他事务修改）;
    快照读: 读取数据时获取事务开始时的快照, 确保读取的数据是一致的
    
8. Mysql 有哪些锁, 大概介绍一下
    1️⃣表级锁: 对整个表加锁
        (1) 读锁: 多个事务可以同时对表加读锁, 但是不能进行写操作;
        (2) 写锁: 当一个事务对表加写锁时, 其他事务不能对该表进行读写操作
    2️⃣行级锁: 对单条记录加锁
        (1) 共享锁: 允许事务读取一行数据, 但不允许修改, 其他事务可以获取该行的共享锁;
        (2) 独占锁: 允许事务读取或修改一行数据, 但是不允许其他事务获取该行的任何锁
    3️⃣间隙锁: 用于防止“幻读”
        (1) 间隙锁: 锁定一个范围内的间隙, 但不锁定间隙中的行;
        (2) 临键锁: 配合行锁锁定当前行及行前的间隙
    4️⃣意向锁: 一种声明行锁意图的表锁, 用于协调行锁和表锁的关系 
        (1) 意向共享锁: 事务打算对表中某些行加共享锁（S锁）;
            如: select ... lock in share mode
        (2) 意向排它锁: 事务打算对表中某些行加排他锁（X锁）
            如: select ... for update、update ...、delete ...
        - 兼容情况:
             ----------------------------------------------
            |当前锁⬇️/请求锁➡️ |  IS   |  IX  |  S   |   X  |
            -----------------------------------------------
            |      IS         |  ✅  |  ✅  |  ✅  |  ❌ |
            -----------------------------------------------
            |      IX         |  ✅  |  ✅  |  ❌  |  ❌ |
            -----------------------------------------------
            |      S          |  ✅  |  ❌  |  ✅  |  ❌ |
            -----------------------------------------------
            |      X          |  ❌  |  ❌  |  ❌  |  ❌ |
            -----------------------------------------------
    等等
    
9. char 和 varchar 的区别
    char 是定长的, 无论存储的字符串长度为多少, 最终都占用定义时的大小（不足则填充）; 适合存储长度固定的字符串;
    varchar 是可变的, 根据存储的长度来决定占用的大小; 适合存储长度可变的字符串

10. 介绍一下 Redo Log
    redo log 记录了所有对数据库的更改操作, 是 InnoDB 用来保证事务持久性的日志文件, 可以在数据库宕机后恢复已经提交但还未刷盘的数据;
    - 为什么需要 Redo Log 呢, 大概讲讲工作流程
        InnoDB 的数据最终都存储在磁盘上的 .ibd 文件; 对于每次 update 都刷新 page 到磁盘中, 但是磁盘 I/O 很慢, 效率很低, 
    所以 InnoDB 采取了 WAL 机制: 先把修改写入日志, 再异步刷新到磁盘; 
        WAL 具体流程: 当数据库在操作数据的时候, 首先会去 Buffer Pool 中找对应数据的页（如果不存在从磁盘刷一份）, 然后直接操作 Buffer Pool, 
    并且把数据产生的更改也记录到 Redo Log Buffer 中, 事务一旦提交, 马上把 Redo Log Buffer 里的数据写入磁盘中的 Redo Log, 
    然后再对 Buffer Pool 里的数据进行异步刷盘;
    Redo Log Buffer 先于 Buffer Pool 写入磁盘确保了当数据库宕机时, 对已提交但未刷盘的数据有恢复的保证
    
11. 聊一下 MySQL 的基础架构
    （图示可见 ./MySQL基础架构.png）
    1️⃣客户端:
        发送 SQL 到 MySQL 服务器
    2️⃣Server 层:
        （1）连接器: 管理连接、权限验证
        （2）分析器: 词法分析、语法分析
        （3）优化器: 生成执行计划、索引选择
        （4）执行器: 操作引擎, 返回结果
    3️⃣存储引擎层:
        存储数据, 提供读写接口

12. 什么是深分页, 常见的解决方案有哪些
    - 概念:
        深分页指的是通过 limit 去进行分页查询时, 偏移量过大的问题;
        - 详细补充: 
            对于 limit M, N， 数据库需要扫描前 M + N 条数据, 然后丢弃前 M 条数据, 只返回后的 N 条数据, 随着 M 的增大, 
            扫描的数据量会变大, 导致查询效率下降;
    - 解决方案:
        深分页的优化主要集中在避免全表扫描和利用索引快速定位;
        （1）依赖主键 / 唯一索引进行优化（推荐）
            如果主键 ID 是递增的, 记住上一页最后一条记录的主键值, 下一页查询直接用范围查询;
            ```sql
            select * 
            from table t 
            where expire_time < :threshold and id > :last_id 
            order by id 
            limit :page_size;
            ```
        （2）覆盖索引进行优化
            先通过覆盖索引查询出需要的数据的主键值, 然后再通过主键值批量查询完整的行数据;
            ```sql
            select * 
            from table t join (
                select id
                from table t
                where expire_time < :threshold
                order by id
                limit M, N
            ) t2
            on t.id = t2.id;
            ```