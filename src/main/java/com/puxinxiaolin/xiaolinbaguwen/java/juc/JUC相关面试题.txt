1. 什么是进程、什么是线程
    进程是操作系统分配资源的基本单位; 线程是进程内的最小执行单元, 共享进程内的资源

2. 用户线程和守护线程的区别
    用户线程是应用程序创建的线程, 也称非守护线程;
    守护线程是为其他线程提供服务和支持的线程, 当所有用户线程结束后, 即使还有守护线程, JVM 也会退出

3. 线程的生命周期
    （图示可见 ./线程生命周期.png）
    1️⃣新建（New）
    2️⃣就绪（Runnable）
    3️⃣运行（Running）
    4️⃣阻塞（Blocked）
    5️⃣等待（Waiting）
    6️⃣超时等待（Timed Waiting）
    7️⃣终止（Terminated）

4. 为什么 Java 多线程调用的是 start() 方法而不是 run() 方法
    因为 start() 会启动一个新线程去执行任务; 而 run() 方法会直接在当前线程中执行

5. 线程池
    5.1 线程池的原理
        线程池是一种管理和复用线程的机制, 通过减少线程创建和销毁的开销来提高系统的响应速度和吞吐量, 可以有效管理和控制线程的数量, 
    防止过多的线程导致系统资源耗尽; 内部维护了任务队列, 当所有线程在忙碌时, 新提交的任务会被放入任务队列, 等待空闲线程来执行;
    - 线程池有七大核心参数: 
        1️⃣核心线程数: 线程池中始终保持运行的最小线程数;
        2️⃣最大线程数: 线程池允许创建的最大线程数; 
        3️⃣线程空闲时间: 超过核心线程数的空闲线程等待新任务的最大时间;
        4️⃣空闲时间单位: 时间单位;
        5️⃣任务队列: 保存等待执行的任务;
        6️⃣线程工厂: 创建新线程的工厂, 可以自定义线程名称、优先级等;
        7️⃣拒绝策略: 当任务队列已满并且当前线程数达到最大线程数时, 新的任务会被拒绝;
            - 四种拒绝策略:
                （1）AbortPolicy（默认）: 抛出 RejectExecutionException;
                （2）CallerRunsPolicy: 由调用线程去执行任务;
                （3）DiscardPolicy: 丢弃任务, 不抛异常;
                （4）DiscardOldestPolicy: 丢弃队列中最早的任务, 然后尝试重新提交新任务
    5.2 介绍一下常用的线程池
        1️⃣FixedThreadPool:
            固定大小线程池, 无论有多少任务提交, 线程池中的线程数始终不变, 没有空闲线程时会把任务加入任务队列中;
        2️⃣CacheThreadPool:
            缓存线程池, 线程数量不固定, 可以根据需要自动创建新线程; 如果线程池中的线程在 60s 内没有被使用, 会被终止并移除;
        没有空闲线程时会创建新线程去处理;
        3️⃣SingleThreadExecutor:
            单线程池, 任务按照提交的顺序执行;
        4️⃣ScheduledThreadPool:
            定时线程池, 可以在给定的延迟后执行或定期执行;
        5️⃣WorkStealingPool:
            工作窃取线程池, 使用多个工作队列减少竞争, 适合并行计算
    5.3 线程池的工作过程:
        当有新任务提交, 如果当前线程数 < 核心线程数, 会直接创建新线程去执行; 如果当前线程数达到最大线程数, 会把任务加入任务队列;
    如果任务队列满了, 并且当前线程数 < 最大线程数, 会创建新线程去执行任务; 如果达到最大线程数, 会根据拒绝策略去做对应的处理;
    在执行完任务后, 若有线程的空闲时间超过设置的最大空闲时间, 并且当前线程数 > 核心线程数, 会销毁掉这些线程

6. 什么是乐观锁
    乐观锁是一种并发控制机制, 用于解决并发修改问题, 它假设并发冲突的概率较低, 在操作之前不加锁, 而是在提交时进行冲突检测;
    - 乐观锁产生的 ABA 问题:
        在变量检查和更新之间被其他线程多次修改, 但最终值一样; 可以通过增加版本号、时间戳或用 Java-API 提供的 AtomicStampedReference 解决
        - 解决方法:
            1️⃣版本号: 给记录新增一个版本号字段, 每次读取记录时获取版本号, 更新记录时检查当前版本号和之前读取的版本号是否一致;
        如果一致, 更新记录并把版本号 + 1; 如果不一致说明有其他事务已经更新了该记录, 需要重试;
            2️⃣时间戳: 给记录新增一个时间戳字段, 每次读取记录时获取时间戳, 更新记录时检查当前时间戳和之前读取的时间戳是否一致;
        如果一致, 更新记录并更新时间戳; 如果不一致说明有其他事务已经更新了该记录, 需要重试;
            3️⃣AtomicStampedReference: Java-API, 内部实现了类似版本号或时间戳的方式来确保线程安全
    

7. 什么是 CAS 
    CAS 是一种用于实现无锁并发控制的数据结构, 允许一个变量在检查和更新之间不会被其他线程修改, 确保操作的原子性; 主要涉及三个操作数:
变量的内存地址、预期值和新值;
    - 执行流程:
        首先读取变量的当前值, 然后比较当前值和预期值, 如果相等则更新为新值并返回 true, 否则返回 false;
    - 可能出现的问题:
        （1）ABA 问题:
            详见 6. 什么是乐观锁 - 乐观锁产生的 ABA 问题;
        （2）自旋等待:
            通常 CAS 操作在失败时会自选等待重试, 可能导致 CPU 资源的浪费

8. 什么是 AQS
    AQS 名为抽象队列同步器, 是一个用于构建锁和同步器的框架; 内部通过一个等待队列来管理线程的排队和唤醒, 简化了同步器的实现;
    - 核心概念:
        1️⃣state: 不同的同步器有不同的含义, 对于独占锁, 可以表示锁的持有状态; 对于共享锁, 可以表示可用资源的数量;
        2️⃣独占模式: 只有一个线程可以获得同步状态, 其他线程必须等待（例如 ReentrantLock）;
        3️⃣共享模式: 多个线程可以获得同步状态（例如 Semaphore、CountDownLatch）;
        （对于独占模式和共享模式的本质可以理解成是否允许多个线程持有 state）
        4️⃣等待队列: 用来保存获取同步状态失败的线程, 等待其他线程释放同步状态后被唤醒;
    - 等待队列 / 同步队列:
        是 CLH 队列的变体, 基于双向链表的 FIFO 队列, 每个线程封装为一个 Node 节点, 通过 pre 和 next 维护队列顺序, 
    每个节点通过 waitStatus 来管理当前线程状态, 有四种状态:
            1️⃣SIGNAL(-1): 表示当前节点的后续节点需要被唤醒;
            2️⃣CANCELLED(1): 表示节点被取消（如超时或中断）;
            3️⃣CONDITION(-2): 表示节点在条件队列中等待（与同步队列无关）;
            4️⃣PROPAGATE(-3): 表示节点在共享模式下唤醒需要传播（如 semaphore 释放资源后连续唤醒）;
    - 条件队列:
        可以理解成线程的等待室, 当线程调用 await(), 它会释放锁并进入条件队列挂起, 直到其他线程调用 signal() 把它唤醒; 
    每个条件队列都是单向链表, 节点存储等待的线程, 被唤醒的线程会从条件队列转移到同步队列, 重新参与抢锁;

    8.1 AQS 怎么实现公平锁和非公平锁的
        公平锁和非公平锁的区别在于获取锁时是否允许插队, 非公平锁的线程会直接抢锁, 不管等待队列里有没有其他线程排队; 而公平锁的线程必须排队,
    只有等待队列里没有其他线程或者自己处于队头才会抢锁（如 ReentrantLock 默认是非公平的, 可以减少线程切换的开销, 提高吞吐量）; 
    对于公平锁, AQS 在 tryAcquire() 中会加一个检查队列是否有等待线程的逻辑来实现这种差异;

    8.2 AQS 为什么使用 CLH 队列
        因为 CLH 结构天生适合实现高效的锁竞争排队, 原始的 CLH 队列基于自旋锁, 每个节点不断自选检查前驱节点的状态, 前驱释放锁后, 当前线程才能获取;
    而 AQS 把自旋改为线程阻塞, 挂起线程从而释放 CPU 资源; 同时节点新增 pre 和 next 指针, 便于快速删除中间节点（线程取消或超时）

9. 有了 synchronized 为什么还需要 Lock
    synchronized 的使用简单, 适合基本的同步需求; 而 Lock 提供更灵活的锁机制, 适合复杂的同步需求; Lock 支持非阻塞式的获取锁, 可以响应外部中断, 
使处于阻塞状态的线程有机会释放曾经获取的锁, 规避死锁问题; 而使用 synchronized 的线程一旦进入阻塞状态, 什么也干不了, 也释放不了线程已经占有的资源, 
有死锁的风险; Lock 接口的实现类如 ReentrantLock 可以设置公平锁, 避免线程饥饿; 而 synchronized 是非公平的, 某些线程可能永远无法获取锁; 
synchronized 的 wait() / notify() 只能绑定一个条件, 但是 Lock 的 newCondition() 可以绑定多个条件, 可以实现更复杂的等待/通知机制

10. 什么是悲观锁
    悲观锁是一种并发控制机制, 用于解决并发修改问题, 它假设并发冲突的概率较高, 在每次操作之前都加锁;
    - 两种类型:
        1️⃣共享锁(读锁): 允许多个事务同时访问数据, 但是不能修改;
        2️⃣排他锁(写锁): 仅允许一个事务修改数据, 其他事务不能访问
    - 常见实现: 
        主要通过数据库的锁机制实现;
        1️⃣行级锁: 锁住一行数据, 避免多线程对同一行数据进行修改, 在 MySQL 中用 select ... for update 实现;
            ```sql
            -- 开始事务
            start transaction;
            
            -- 获取行锁
            select * 
            from t 
            where id = 1 for update;

            update t
            set num = num - 1
            where id = 1;

            -- 提交事务
            commit;
            ```
        2️⃣表级锁: 锁住一张表, 避免多线程对同一张表进行修改, 在 MySQL 中用 lock table write/read 实现;
            ```sql
            -- 锁定表
            lock t write/read;

            update t
            set num = num - 1
            where id = 1;

            -- 解锁表
            unlock tables;
            ```
        3️⃣数据库锁: 锁住数据库表, 避免多线程对同一张表进行修改;

11. 创建线程池的底层原理
    首先当我们调用线程的 start() 方法时, 会额外创建一个新线程去执行, 而是会调用本地方法里的 start0() 方法, 这个方法内部又会调用操作系统里的
pthread_create() 方法来创建一个内核线程, 这个过程涉及用户态到内核态的切换, 耗时且耗资源, 所以为了避免线程被频繁创建销毁的开销, 就有了线程池

12. JVM 的线程调度是什么
    线程调度是 JVM 管理和分配 CPU 时间片给其他线程的过程; 
    - 主要有两种类型: 
        1️⃣抢占式调度: JVM 中断当前正在执行的线程, 把 cpu 分配给另一个线程;
        2️⃣协作式调度: 线程主动让出 cpu
    - 调度策略:
        1️⃣时间片轮转: 线程按顺序获得固定长度的时间片, 时间片用完调度器会把 cpu 分配给下一个线程, 每个线程都有机会执行;
        2️⃣优先级调度: 调度器选择优先级高的线程执行, 如果有多个同等优先级的线程, 再按照时间片轮转的方式调度
    - 常见问题:
        1️⃣线程饥饿: 对于优先级低的线程可能一直获取不到 cpu 时间片, 导致无法执行;
        2️⃣活锁: 类似死锁, 但是线程并未阻塞, 而是不断改变状态, 无法继续执行

13. 线程安全的三大特性
    1️⃣原子性: 线程操作要么全部执行要么全部不执行, 不会被其他线程干扰;
    2️⃣可见性: 线程对共享变量的修改对其他线程可见;
    3️⃣有序性: 线程操作的顺序按照代码的顺序执行;
        - 主要通过内存屏障实现

14. 介绍一下 volatile
    volatile 是一个 Java 中的关键字, 确保变量的可见性（每次修改或者读取都通过主存）和有序性（指令禁重排）; 一旦有其他线程修改了被 volatile 修饰的变量, 新值会被立即刷新到主存中, 
并且其他线程读取这个值会从主存中读取, 确保可见性; 并且还通过内存屏障来实现有序性;
    - 内存屏障的四种类型:
        --------------------------------------------------------------------------------------------------
        |  屏障类型    |           指令实例            |                           说明                      |
        --------------------------------------------------------------------------------------------------
        | LoadLoad   | Load1 : LoadLaod : Load2     | 确保 load1 的读操作都在 load2 及之后的读操作之前读取完毕   |
        --------------------------------------------------------------------------------------------------
        | StoreStore | Store1 : StoreStore : Store2 | 确保 store1 的写操作都在 store2 及之后的写操作之前写入完毕 |
        ---------------------------------------------------------------------------------------------------
        | LoadStore  | Load1 : LoadStore : Store2   | 确保 Load1 的读操作都在 store2 及之后的写操作之前读取完毕  |
        ---------------------------------------------------------------------------------------------------
        | StoreLoad  | Store1 : StoreLoad : Load2   | 确保 store1 的写操作都在 load2 及之后的读操作之前都执行完毕 |
        ---------------------------------------------------------------------------------------------------

15. synchronized 的底层实现原理
    synchronized 在 Java 中主要用于实现线程同步, 确保同一时间内只有一个线程可以执行代码块或方法; 
它的实现基于 JVM 和操作系统中提供的锁机制; 它依赖于一个称为 “监视器”(Monitor) 的机制, 每个对象在 Java 中都有一个与之对应的监视器锁(Monitor Lock), 
当一个线程进入一个 synchronized 方法或代码块时, 它会尝试获取该对象的监视器锁;
    在 JVM 层面中, synchronized 会被编译器转换为字节码中的两条指令: monitorenter 和 monitorexit; 当线程进入同步方法或代码块时, 尝试获取对象的监视器锁, 
如果锁已经被持有了, 当前线程会阻塞, 直到锁被释放; 当线程退出同步方法或代码块时, 释放对象的监视器锁