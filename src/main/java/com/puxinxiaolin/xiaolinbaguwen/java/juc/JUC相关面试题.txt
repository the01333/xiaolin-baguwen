1. 什么是进程、什么是线程
    进程是操作系统分配资源的基本单位; 线程是进程内的最小执行单元, 共享进程内的资源

2. 用户线程和守护线程的区别
    用户线程是应用程序创建的线程, 也称非守护线程;
    守护线程是为其他线程提供服务和支持的线程, 当所有用户线程结束后, 即使还有守护线程, JVM 也会退出

3. 线程的生命周期
    （图示可见 ./线程生命周期.png）
    1️⃣新建（New）
    2️⃣就绪（Runnable）
    3️⃣运行（Running）
    4️⃣阻塞（Blocked）
    5️⃣等待（Waiting）
    6️⃣超时等待（Timed Waiting）
    7️⃣终止（Terminated）

4. 为什么 Java 多线程调用的是 start() 方法而不是 run() 方法
    因为 start() 会启动一个新线程去执行任务; 而 run() 方法会直接在当前线程中执行

5. 线程池
    5.1 线程池的原理
        线程池是一种管理和复用线程的机制, 通过减少线程创建和销毁的开销来提高系统的响应速度和吞吐量, 可以有效管理和控制线程的数量, 
    防止过多的线程导致系统资源耗尽; 内部维护了任务队列, 当所有线程在忙碌时, 新提交的任务会被放入任务队列, 等待空闲线程来执行;
    - 线程池有七大核心参数: 
        1️⃣核心线程数: 线程池中始终保持运行的最小线程数;
        2️⃣最大线程数: 线程池允许创建的最大线程数; 
        3️⃣线程空闲时间: 超过核心线程数的空闲线程等待新任务的最大时间;
        4️⃣空闲时间单位: 时间单位;
        5️⃣任务队列: 保存等待执行的任务;
        6️⃣线程工厂: 创建新线程的工厂, 可以自定义线程名称、优先级等;
        7️⃣拒绝策略: 当任务队列已满并且当前线程数达到最大线程数时, 新的任务会被拒绝;
            - 四种拒绝策略:
                （1）AbortPolicy（默认）: 抛出 RejectExecutionException;
                （2）CallerRunsPolicy: 由调用线程去执行任务;
                （3）DiscardPolicy: 丢弃任务, 不抛异常;
                （4）DiscardOldestPolicy: 丢弃队列中最早的任务, 然后尝试重新提交新任务
    5.2 介绍一下常用的线程池
        1️⃣FixedThreadPool:
            固定大小线程池, 无论有多少任务提交, 线程池中的线程数始终不变, 没有空闲线程时会把任务加入任务队列中;
        2️⃣CacheThreadPool:
            缓存线程池, 线程数量不固定, 可以根据需要自动创建新线程; 如果线程池中的线程在 60s 内没有被使用, 会被终止并移除;
        没有空闲线程时会创建新线程去处理;
        3️⃣SingleThreadExecutor:
            单线程池, 任务按照提交的顺序执行;
        4️⃣ScheduledThreadPool:
            定时线程池, 可以在给定的延迟后执行或定期执行;
        5️⃣WorkStealingPool:
            工作窃取线程池, 使用多个工作队列减少竞争, 适合并行计算
    5.3 线程池的工作过程:
        当有新任务提交, 如果当前线程数 < 核心线程数, 会直接创建新线程去执行; 如果当前线程数达到最大线程数, 会把任务加入任务队列;
    如果任务队列满了, 并且当前线程数 < 最大线程数, 会创建新线程去执行任务; 如果达到最大线程数, 会根据拒绝策略去做对应的处理;
    在执行完任务后, 若有线程的空闲时间超过设置的最大空闲时间, 并且当前线程数 > 核心线程数, 会销毁掉这些线程

6. 什么是乐观锁
    乐观锁是一种并发控制机制, 用于解决并发修改问题, 它假设并发冲突的概率较低, 在操作之前不加锁, 而是在提交时进行冲突检测;
    - 主要实现:
        1️⃣版本号: 给记录新增一个版本号字段, 每次读取记录时获取版本号, 更新记录时检查当前版本号和之前读取的版本号是否一致;
    如果一致, 更新记录并把版本号 + 1; 如果不一致说明有其他事务已经更新了该记录, 需要重试;
        2️⃣时间戳: 给记录新增一个时间戳字段, 每次读取记录时获取时间戳, 更新记录时检查当前时间戳和之前读取的时间戳是否一致;
    如果一致, 更新记录并更新时间戳; 如果不一致说明有其他事务已经更新了该记录, 需要重试
    - 乐观锁产生的 ABA 问题:
        
7. 

8. 

9. 