1. 一次完整的垃圾回收过程是什么样的
    主要分为三个步骤:
        1️⃣垃圾分类
            在进行垃圾回收的时候需要确定哪些对象是垃圾对象, 哪些对象是存活对象; 具体流程就是垃圾回收器会从堆的根节点(gc root)出发, 开始遍历对象图;
        标记所有可达的对象为存活对象, 未被标记的为垃圾对象, 这样就实现了分类;
            1.1. gc root 对象包含哪些
                虚拟机栈（栈帧的本地方法表）中的引用、方法区中的类静态变量引用、方法区中的常量引用、本地方法栈中的 JNI 引用、活动线程、类加载器、
            系统类、JNI 的全局引用、JNI 内部的某些数据结构
            1.2. 怎么判断对象是否可达
                可以通过引用计数法和可达性分析法这两种垃圾回收算法来判断;
                    （1）引用计数法
                        每个对象都有一个引用计数器, 记录着指向该对象的引用数量; 当一个对象被引用时, 引用计数器 + 1; 当一个引用被释放时, 引用计数器 - 1;
                    当引用计数器为 0, 表示没有任何引用指向该对象, 该对象可以被释放, 回收其占用的内存;
                        - 优点:
                            简单高效、实时性好、无需沿着指针查找
                        - 缺点:
                            存在循环引用问题（对象之间的引用计数器可能永远不会为 0, 有内存泄露的可能）、额外开销（每个对象都需要维护一个引用计数器）、
                        不支持并发
                    （2）可达性分析法（JVM 中常用的）
                        从 gc root 开始, 递归访问所有可达对象（DFS、BFS 实现）, 并打上标记;
                        - 优点:
                            具有准确性、效率高、灵活性强（可以和其他垃圾回收算法结合使用）
        2️⃣垃圾查找
            分类后, JVM 会根据分类后的对象, 找出所有的垃圾对象, 以便进行清理;
        3️⃣垃圾清除
            在标记和查找后, 根据不同的垃圾回收算法（取决于不同的垃圾收集器）进行垃圾清理;

2. JVM 垃圾回收算法有哪些
    垃圾回收算法主要是为了解决两个问题, 一个是确定哪些对象可以被回收（引用计数法、可达性分析法）, 一个是如何回收这些对象;
    1️⃣引用计数法
        详见 1. - 1.2.
    2️⃣可达性分析法
        详见 1. - 1.2.
    3️⃣标记-清除算法
        垃圾收集器先遍历对象图, 标记所有的可达对象, 然后清除未被标记的对象;
        - 优点: 
            简单直接, 不需要移动对象;
        - 缺点:
            会产生内存碎片, 导致大对象分配失败;
    4️⃣标记-整理算法:
        同上标记所有可达对象后, 压缩阶段会把所有存活的对象移到内存的一侧, 整理出连续的可用空间;
        - 优点: 
            不会产生内存碎片;
        - 缺点:
            移动对象需要额外的开销;
    5️⃣复制算法:
        把内存分为两个区域, 每次只使用其中一个; 当一个区域用完后, 把存活的对象复制到另一个区域, 然后清空当前区域;
        - 优点: 
            简单高效, 不会产生内存碎片;
        - 缺点:
            需要双倍的内存空间;
    6️⃣分代收集算法:
        根据对象的生命周期把堆空间分为几代（通常是新生代和老年代）, 新生代使用复制算法, 老年代使用标记-整理算法 / 标记-清除算法;
        - 优点:
            垃圾收集效率高（因为大部分对象都在新生代被收集, 减少了老年代的垃圾收集频率）;
        - 缺点:
            需要额外的内存管理和调优;
    7️⃣分区算法:
        把堆内存划分为多个小区域, 每个区域可以独立进行垃圾收集;
        - 优点: 
            内存管理的灵活性高;
        - 缺点:
            实现比较复杂, 需要精细的内存管理
    2.1 具体垃圾收集器使用的算法
        （1）Serial GC: 标记-整理算法;
        （2）Parallel GC: 新生代使用复制算法, 老年代使用标记-整理算法;
        （3）CMS GC: 新生代使用复制算法, 老年代使用标记-清除算法, 并发标记和清理;
        （4）G1 GC: 分区算法, 结合标记-整理算法和复制算法;
        （5）ZGC: 分区算法, 使用染色指针和读屏障技术, 实现并发标记和压缩;

3. JVM 的组成部分有哪些
    1️⃣类加载子系统
        负责把 .class 文件加载到内存中, 并进行验证、准备、解析、初始化;
        - 主要功能:
            （1）验证: 确保字节码文件的正确性和安全性;
            （2）准备: 为类的静态变量分配内存并设置默认初始值;
            （3）解析: 把符号引用转为直接引用;
            （4）初始化: 执行类的静态代码块和初始化静态变量;
    2️⃣运行时区域
        （1）堆: 存储所有对象实例和数组, 是垃圾回收的主区域;
            3.1. 堆内部结构是什么
                （1）新生代
                    用于存储新创建的对象, 戏份为三个区域: Eden 区、幸存者区（S0 和 S1）; 
                在每次的 Minor GC 之后, 仍然存活的对象会从 Eden 区和当前的幸存者区复制到另一个幸存者区; 两个幸存者区交替使用;
                （2）老年代
                    用于存储生命周期较长的对象, 新生代经历 15 次 Minor GC 后进入老年代; 老年代的垃圾回收次数较少, 但时间较长, 
                称为 Major GC / Full GC;
                （3）永久代/元空间
                    这两个都是方法区的实现, 可以把方法区看作接口, 永久代/元空间看成实现类; 在 JDK 1.7 及之前, 永久代用于存储类的元数据、
                常量池、静态变量等; 永久代的大小是固定的, 容易导致 OOM; 而在 JDK 1.8 及之后永久代被元空间取代, 也不和之前一样在 JVM 堆中,
                而是使用本地内存; 元空间的大小可以动态调整, 减少了 OOM 的风险;
            - 堆内存的配置:
                - -Xms: 设置堆空间的初始大小;
                - -Xmx: 设置堆空间的最大大小;
                - -XX:NewSize: 设置新生代的初始大小;
                - -XX:MaxNewSize: 设置新生代的最大大小;
                - -XX:SurvivorRatio: 设置 Eden 区与幸存者区的比例;
        （2）方法区: 存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等;
        （3）虚拟机栈: 每个线程都有自己的栈, 存储局部变量表、操作数栈、动态链接、方法返回地址;
        （4）程序计数器: 每个线程都有自己的程序计数器, 记录当前线程执行的字节码行号;
        （5）本地方法栈: 为本地方法调用服务;
    3️⃣执行引擎:
        （1）解释器: 逐条解释执行字节码指令, 速度较慢;
        （2）即时编译器: 把热点代码（频繁执行的代码）编译为本地机器码, 提高执行速度;
        （3）垃圾收集器: 自动管理内存, 回收不再使用的对象(垃圾对象), 避免内存泄漏;
    4️⃣本地接口:
        允许 Java 代码和本地代码交互;
    5️⃣本地方法库:
        存储本地方法实现的动态链接库, 提供本地方法的具体实现