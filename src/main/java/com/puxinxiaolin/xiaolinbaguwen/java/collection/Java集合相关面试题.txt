1. ArrayList
    1.1 讲讲 Arraylist
        ArrayList 是线程不安全的, 它实现了 List 接口, 基于动态数组实现, 还实现了 RandomAccess 接口, 允许对元素快速随机访问; 
    对于中间位置进行添加、删除元素时, 需要对数组进行复制、移动, 代价比较高, 因此它适合遍历查找, 不适合插入和删除;
    因为是数组实现的, 如果需要扩容需要把数组的数据复制到新内存空间中, 扩容的新容量为原来的 1.5 倍（newCapacity = oldCapacity + (oldCapacity >> 1)）;
    在 JDK 1.7 之后, 它默认使用懒加载机制, 初始化的时候为空数组, 当放入元素的时候才会给数组分配大小为 10 的容量
    
    1.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedList();
        3️⃣使用 CopyOnWriteArrayList()

2. LinkedList
    2.1 讲讲 LinkedList
        ArrayList 是线程不安全的, 它实现了 List 接口, 基于双向链表实现; 
    对于中间位置进行添加、删除元素时, 需要先找到目标节点, 再修改指针, 效率受节点位置影响;
    它还实现了 Deque 接口, 可以作为双端队列、栈等其他数据结构来使用
    
    2.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedList();
        3️⃣如果作为队列使用, 可以使用 ConcurrentLinkedQueue() / ConcurrentLinkedDeque()

3. HashSet
    3.1 讲讲 HashSet
        HashSet 是线程不安全的, 它实现了 List 接口, 基于 HashMap 实现; 具有快速的插入、删除和查找
    
    3.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedSet();
        3️⃣使用 ConcurrentHashMap.newEntrySet();
        4️⃣使用 CopyOnWriteArraySet()

4. HashMap
    4.1 讲讲 HashMap
        HashMap 不是线程安全的, 它是基于哈希表（数组 + 链表）实现的, 提供快速插入、查找和删除; 它允许一个 null 键和多个 null 值;
    当哈希表中"桶"的链表长度 ≥ 8, 并且数组容量 ≥ 64, 会把链表转为红黑树
        - 工作原理:
            1️⃣数组 + 链表（树）:
                HashMap 使用数组来存储链表或树结构（Java 8 及之后）, 每个位置称为“桶”, 存储链表或者树;
            2️⃣哈希函数:
                当放入元素的时候, 会先利用键的 hashCode() 获取哈希值, 然后映射到数组的索引位置;
            在 Java 8 及之后使用“扰动函数”来让哈希值分布更均匀, 避免哈希冲突; 
            主要是对获取到的键的哈希值 h >>> 16 再和自身做异或 ^ 运算, 即最终的哈希值 = h ^ (h >>> 16)
            3️⃣哈希冲突/碰撞:
                当两个键的哈希值相同（哈希冲突）, 会存在同一个“桶”中, 形成一个链表（到达阈值转换为树）;
                - 解决方法:
                    （1）拉链法: 每个"桶"包含一个链表, 发生哈希冲突加到桶里的链表中, 在 JDK 8 及以上版本链表长度超过一定阈值会转为红黑树;
                    （2）开放地址法: 
                        （2.1）线性探测: 依次往后查找空闲位置;
                        （2.2）二次探测: 按照平方序列查找空闲位置;
                        （2.3）双重散列: 用两个不同的哈希函数, 当第一个发生哈希冲突使用第二个;
                        （2.4）再哈希法: 使用不同的哈希函数重新计算哈希值;
            4️⃣再哈希:
                当元素数量超过容量的负载因子（默认 0.75）, 会进行“再哈希”: 创建一个容量为原来两倍（确保是 2 的幂次）的新数组并迁移旧数据; 
            迁移时, 通过“扰动函数”重新计算所有元素的哈希值, 然后计算新的索引位置
        - 为什么容量扩容一定是 2 的幂次
            1️⃣高效计算索引:
                HashMap 中索引的计算 = (数组长度 - 1) & 哈希值;
            2️⃣减少哈希冲突;
            3️⃣简化扩容;
            4️⃣内存对齐和提高访问效率
        - HashMap 的扩容过程
            1️⃣采用懒加载, 添加元素时如果数组为空, 会给数组分配 16 的大小, 负载因子为 0.75;
            2️⃣如果数组元素数量 ≥ 数组容量 * 负载因子, 会创建一个容量为原来两倍（确保是 2 的幂次）的新数组并迁移旧数据; 
        迁移时, 通过“扰动函数”重新计算所有元素的哈希值, 然后计算新的索引位置
        - 拉链法导致链表过深为什么用红黑树
            红黑树是一种自平衡二叉搜索树, 具有高效的查找、插入、删除, 它的自平衡机制保证树的高度保持在一个较低水平, 
        避免链表过长导致的性能问题

5. ConcurrentHashMap
    5.1 讲讲 ConcurrentHashMap
        ConcurrentHashMap 是一种高效的线程安全的哈希表, 主要用于在多线程环境下进行高并发读写;
    和 HashMap 底层实现类似, 都是数组 + 链表 / 红黑树; 但是不允许 null 键或 null 值;
    在 Java 7 及之前使用“分段锁”确保高并发, 把整个哈希表分成多个段（默认 16 个）, 每个段维护一个独立的哈希表（每个节点为 HashEntry）和锁;
    在 Java 8 及之后摒弃了“分段锁”, 转而采用 CAS 无锁机制, 读写操作大部分情况下无需加锁, 由 volatile 变量和 CAS 操作保证线程安全;
    同 HashMap 一样, 数组里的每个槽位称为“桶”, 也存储链表, 并且达到一定阈值也会转为红黑树, 提高查询效率
        - 扩容机制: 
            采用渐进式扩容机制, 避免扩容途中长时间的全表锁定, 在每次插入或删除时逐步迁移数据
        - 为什么不允许 null 键或 null 值
            为了避免歧义, 在多线程环境中, 如果获取的结果为空, 调用方就不知道这个键是存的值为空还是这个键根本不存在

6. 了解 fail-fast 机制吗
    fail-fast 是一种用于检测在遍历集合过程中是否发生结构性修改的机制, 如果检测到了会立刻抛出异常以防不一致状态下的操作;
    - 工作原理:
        当集合通过迭代器进行遍历时, 会维护一个修改计数器, 当集合的结构发生改变计数器就会递增; 当创建迭代器时, 它会保存当前的计数器的值, 
    当调用 next() 方法时, 会把当前计数器的值和之前保存的值进行比较, 如果不一致会抛出 ConcurrentModificationException 异常（证明迭代过程中发生了结构性的修改）, 快速失败
    
7. 了解过 fail-safe 机制吗
    fail-safe 是一种相对于 fail-fast 的机制, 它在检测过程中如果检测到了发生结构性的修改, 不会抛出 ConcurrentModificationException 异常, 而是允许修改继续进行
    - 工作原理:
        当集合通过迭代器进行遍历时, 其实遍历的是集合的副本, 这样即使原集合发生修改也不会影响到迭代器正在遍历的副本（需要注意数据一致性的问题）
    
8. 什么是 BlockingQueue（阻塞队列）, 简单聊聊
    阻塞队列是一种在队列的基础上额外支持阻塞机制的线程安全的队列, 常用于多线程中的生产消费问题; 对于每次的 put(), 
如果队列满了会阻塞, 直到有空间可以插入; 对于每次的 take(), 如果队列为空会阻塞, 直到有元素可以获取
    - 基本原理:
        阻塞队列通过使用锁（ReentrantLock）来确保线程安全, 确保同一时间只有一个线程可以执行插入或删除操作, 从而避免并发问题;
    还使用条件变量（和锁关联, 可以在特定情况下阻塞线程并在条件满足时唤醒线程）来管理线程的等待和唤醒
    - 具体的实现:
        1️⃣ArrayBlockingQueue: 基于数组的有界阻塞队列;
        2️⃣LinkedBlockingQueue: 基于链表的可选有界阻塞队列;
        3️⃣PriorityBlockingQueue: 支持优先级排序的无界阻塞队列;
        4️⃣DelayQueue: 支持延迟元素的无界阻塞队列;
        5️⃣SynchronousQueue: 不存储元素的阻塞队列, 每个插入操作必须等待一个对应的移除操作;
        6️⃣LinkedTransferQueue: 基于链表的无界阻塞队列, 支持传输操作
    