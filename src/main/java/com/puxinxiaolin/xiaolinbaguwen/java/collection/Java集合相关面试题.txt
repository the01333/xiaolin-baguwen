1. ArrayList
    1.1 讲讲 Arraylist
        ArrayList 是线程不安全的, 它实现了 List 接口, 基于动态数组实现, 还实现了 RandomAccess 接口, 允许对元素快速随机访问; 
    对于中间位置进行添加、删除元素时, 需要对数组进行复制、移动, 代价比较高, 因此它适合遍历查找, 不适合插入和删除; 
    因为是数组实现的, 如果需要扩容需要把数组的数据复制到新内存空间中, 扩容的新容量为原来的 1.5 倍（newCapacity = oldCapacity + (oldCapacity >> 1)）;
    在 JDK 1.7 之后, 它默认使用懒加载机制, 初始化的时候为空数组, 当放入元素的时候才会给数组分配大小为 10 的容量
    
    1.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedList();
        3️⃣使用 CopyOnWriteArrayList()

2. LinkedList
    2.1 讲讲 LinkedList
        ArrayList 是线程不安全的, 它实现了 List 接口, 基于双向链表实现; 
    对于中间位置进行添加、删除元素时, 需要先找到目标节点, 再修改指针, 效率受节点位置影响;
    它还实现了 Deque 接口, 可以作为双端队列、栈等其他数据结构来使用
    
    2.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedList();
        3️⃣如果作为队列使用, 可以使用 ConcurrentLinkedQueue() / ConcurrentLinkedDeque()

3. HashSet
    3.1 讲讲 HashSet
        HashSet 是线程不安全的, 它实现了 List 接口, 基于 HashMap 实现; 具有快速的插入、删除和查找
    
    3.2 怎么确保线程安全
        1️⃣使用 synchronized 手动同步;
        2️⃣使用 Collections 的 synchronizedSet();
        3️⃣使用 ConcurrentHashMap.newEntrySet();
        4️⃣使用 CopyOnWriteArraySet()

4. HashMap
    4.1 讲讲 HashMap
        HashMap 不是线程安全的, 它是基于哈希表（数组 + 链表）实现的, 提供快速插入、查找和删除; 它允许一个 null 键和多个 null 值;
    当哈希表中"桶"的链表长度 ≥ 8, 并且数组容量 ≥ 64, 会把链表转为红黑树
        - 工作原理:
            1️⃣数组 + 链表（树）:
                HashMap 使用数组来存储链表或树结构（Java 8 及之后）, 每个位置称为“桶”, 存储链表或者树;
            2️⃣哈希函数:
                当放入元素的时候, 会先利用键的 hashCode() 获取哈希值, 然后映射到数组的索引位置;
            在 Java 8 及之后使用“扰动函数”来让哈希值分布更均匀, 避免哈希冲突; 
            主要是对获取到的键的哈希值 h >>> 16 再和自身做异或 ^ 运算, 即最终的哈希值 = h ^ (h >>> 16)
            3️⃣哈希冲突/碰撞:
                当两个键的哈希值相同（哈希冲突）, 会存在同一个“桶”中, 形成一个链表（到达阈值转换为树）;
                - 解决方法:
                    （1）拉链法: 每个"桶"包含一个链表, 发生哈希冲突加到桶里的链表中, 在 JDK 8 及以上版本链表长度超过一定阈值会转为红黑树;
                    （2）开放地址法: 
                        （2.1）线性探测: 依次往后查找空闲位置;
                        （2.2）二次探测: 按照平方序列查找空闲位置;
                        （2.3）双重散列: 用两个不同的哈希函数, 当第一个发生哈希冲突使用第二个;
                        （2.4）再哈希法: 使用不同的哈希函数重新计算哈希值;
            4️⃣再哈希:
                当元素数量超过容量的负载因子（默认 0.75）, 会进行“再哈希”: 创建一个容量为原来两倍（确保是 2 的幂次）的新数组并迁移旧数据; 
            迁移时, 通过“扰动函数”重新计算所有元素的哈希值, 然后计算新的索引位置
        - 为什么容量扩容一定是 2 的幂次
            1️⃣高效计算索引:
                HashMap 中索引的计算 = (数组长度 - 1) & 哈希值;
            2️⃣减少哈希冲突;
            3️⃣简化扩容;
            4️⃣内存对齐和提高访问效率
        - HashMap 的扩容过程
            1️⃣采用懒加载, 添加元素时如果数组为空, 会给数组分配 16 的大小, 负载因子为 0.75;
            2️⃣如果数组元素数量 ≥ 数组容量 * 负载因子, 会创建一个容量为原来两倍（确保是 2 的幂次）的新数组并迁移旧数据; 
        迁移时, 通过“扰动函数”重新计算所有元素的哈希值, 然后计算新的索引位置
        - 拉链法导致链表过深为什么用红黑树
            红黑树是一种自平衡二叉搜索树, 具有高效的查找、插入、删除, 它的自平衡机制保证树的高度保持在一个较低水平, 
        避免链表过长导致的性能问题

5. ConcurrentHashMap
    5.1 讲讲 ConcurrentHashMap
        ConcurrentHashMap 是一种高效的线程安全的哈希表, 主要用于在多线程环境下进行高并发读写; 
    和 HashMap 底层实现类似, 都是数组 + 链表 / 红黑树; 但是不允许 null 键或 null 值;
    在 Java 7 及之前使用“分段锁”确保高并发, 把整个哈希表分成多个段（默认 16 个）, 每个段维护一个独立的哈希表（每个节点为 HashEntry）和锁;
    在 Java 8 及之后摒弃了“分段锁”, 转而采用 CAS 无锁机制, 读写操作大部分情况下无需加锁, 由 volatile 变量和 CAS 操作保证线程安全;
    同 HashMap 一样, 数组里的每个槽位称为“桶”, 也存储链表, 并且达到一定阈值也会转为红黑树, 提高查询效率
        - 扩容机制: 
            采用渐进式扩容机制, 避免扩容途中长时间的全表锁定, 在每次插入或删除时逐步迁移数据