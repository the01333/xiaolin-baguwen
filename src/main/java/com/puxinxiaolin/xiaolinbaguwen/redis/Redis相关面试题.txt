1. 介绍一下 SDS
    Redis 底层字符串实现用的是自己实现的 SDS, 而不是 C 的原生字符串; SDS 由头部和缓存两部分组成, 头部包含len、alloc、flags, 缓存则存储实际字符串; 
由于头部中存储 len, 所以无需像 C 那样获取长度需要从头遍历; SDS 可以存储二进制数据, 因为 C 中的字符串以 \0 结尾; 通过预分配和惰性释放, 减少内存分配的开销

2. List 的底层实现
    由 quickList 实现, 如果元素数量少并且元素较小时, 用 zipList 节省内存; 当数据量增大或元素较大时, 自动转为 quickList（由多个 zipList 组成的双向链表）; 
zipList 节点的大小由 list-max-ziplist-size 控制, 默认 8 KB

3. ZSet 的底层实现
    由 skipList + dict 实现, dict 用于通过 member 快速查找 score, skipList 用于按 score 排序（范围查询）; 
skipList 本质就是加了多层索引的有序链表, 每一层跳跃的范围随着层级的减小而减小, 查找效率高;
    - skipList 查找流程:
        ------------------ skipList 示意图 --------------------
        |第三层  1 ----------------> 9                        |
        |第二层  1 ------> 5 ------> 9 ------> 13             |
        |第一层  1 -> 3 -> 5 -> 7 -> 9 -> 11 -> 13 -> 15      |
        -----------------------------------------------------—
        假设现在要查找节点 13, 首先从最高层（第三层）开始, 从左到右移动, 直到下一个节点的值大于目标, 由于到底了, 9 比 13 小, 跳到下一层;
    一样的流程继续查找, 直到最后一层（第一层）找到目标节点 13

4. Hash 的底层实现
    由 zipList（新版本用 listPack） + hashTable 实现, 如果元素数量少并且元素较小时, 用 zipList 节省内存; 当数据量增大或元素较大时, 自动转为 hashTable; 
    - 转换条件:
        1️⃣Hash 中的字段数超过 hash-max-ziplist-entries 阈值（默认 512）;
        2️⃣任意一个字段或值的长度超过 hash-max-ziplist-value 阈值（默认 64 KB）

5. Redis 有哪些数据类型
    - 基本数据类型:
        String、Hash、ZSet、List、Set
    - 高级数据类型:
        Bitmaps、HyperLogLog、Geospatial Indexes、Stream

6. Redis 为什么这么快
    1️⃣基于内存操作, 读写速度快;
    2️⃣Redis 是单线程模型, 避免并发开销;
    3️⃣I/O 多路复用处理并发连接;
    4️⃣底层数据结构的优化
    
7. 缓存穿透、击穿、雪崩, 解决方案
    1️⃣缓存穿透:
        高并发请求一个 key 但是这个 key 在 Redis 中不存在, 查数据库也不存在, 导致缓存一直没数据, 不断请求数据库;
        - 解决方案:
            （1）缓存空值
            （2）布隆过滤器
            （3）缓存预热
    2️⃣缓存击穿:
        高并发请求一个 key 但是这个 key 在 Redis 中过期了, 导致大量请求打到数据库, 可能造成数据库崩溃宕机;
        - 解决方案:
           （1）互斥锁
           （2）热点 key 永不过期
           （3）缓存预热 + 错开过期时间
    3️⃣缓存雪崩:
        高并发请求中, 大量 key 过期, 导致大量请求打到数据库, 可能造成数据库崩溃宕机;
        - 解决方案:
           （1）缓存预热 + 错开过期时间
           
8. 聊聊分布式锁
    分布式锁主要由 Redis 的 setNx 命令实现, 如果 key 不存在才会设置成功;
    - 改进:
        1️⃣设置过期时间, 避免死锁;
        2️⃣定期续约锁, 确保锁在持有期间不会被其他节点获取;
        3️⃣使用适合的锁竞争算法, 减少锁竞争的开销
    
9. 介绍一下“看门狗”机制
    看门狗是一种自动续约分布式锁的机制, 确保业务在执行完之前锁不会过期;
    - 具体流程:
        当客户端获取到锁时, 会在 Redis 设置一个 key 和过期时间, 然后 Redisson 会启动一个后台任务去“轮询”锁的状态, 
    间隔为过期时间的三分之一; 当锁还被占用的时候, 会重置过期时间为初始值, 这样就实现了延长锁的过期时间
     
10. 谈谈你对 Big Key 的理解
    Big Key 就是某个 key 的 value 很大, 占用大量的内存;
    - 危害:
        1️⃣由于 Redis 是单线程的, 如果操作 Big Key, 可能导致后续的请求阻塞;
        2️⃣读取 Big Key 的内存比其他 key 还要大, 可能导致 OOM;
        3️⃣删除一个 Big Key 造成主库较长时间阻塞并引发同步中断或主从切换
    - 解决方案:
        1️⃣对 Big Key 做拆分, 可以拆分成 key-value 的形式, 然后通过 mget 批量获取;
        2️⃣使用 UNLINK 对 Big Key 做清理;
        3️⃣定期清理无效数据

11. 内存淘汰策略了解吗
    1️⃣noeviction（默认策略）: 不删除任何 key, 内存不足直接报错;
    2️⃣allkeys-lru: 使用最近最少使用算法（LRU）回收所有 key;
    3️⃣volatile-lru: 使用最近最少使用算法（LRU）回收所有设置过期时间的 key;
    4️⃣allkeys-random: 随机回收所有 key;
    5️⃣volatile-random: 随机回收所有设置过期时间的 key;
    6️⃣volatile-ttl: 回收剩余生存时间（TTL）最短的 key;
    7️⃣allkeys-lfu: 使用最长时间没有被使用算法（LFU）回收所有 key
    8️⃣volatile-lfu: 使用最长时间没有被使用算法（LFU）回收所有设置过期时间的 key;
    - 使用方式:
        （1）redis.conf:
            maxmemory 100mb
            maxmemory-policy allkeys-lru
        （2）命令执行
            redis-server --maxmemory 100mb --maxmemory-policy allkeys-lru

12. Redis 有哪些持久化机制
    有 RDB、AOF 和混合持久化三种方式;
    1️⃣RDB: 
        在指定的时间间隔内生成数据集的快照, 并保存到磁盘上, 生成一个 rdb 格式的二进制文件, 容易备份, 恢复速度快, 适用于灾难恢复;
    2️⃣AOF:
        记录每一个写操作追加到 AOF 日志文件中, 每次恢复时进行命令重放;
    3️⃣混合持久化:
        生成 AOF 文件时, 先创建一个 rdb 快照, 然后在快照之后追加 AOF 日志